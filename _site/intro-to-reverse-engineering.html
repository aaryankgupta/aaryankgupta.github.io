<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Pradipta  Bora | Introduction To Reverse Engineering</title>
<meta name="description" content="">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet" href="https://gitcdn.link/repo/jwarby/jekyll-pygments-themes/master/github.css" />
<script src="https://cdn.jsdelivr.net/npm/@splidejs/splide@3.6.4/dist/js/splide.min.js"></script>
<!-- Styles -->
<link rel="shortcut icon" href="/assets/img/favicon.ico">
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@splidejs/splide@3.6.4/dist/css/splide.min.css">

<link rel="canonical" href="/intro-to-reverse-engineering">

<script>
 document.addEventListener( 'DOMContentLoaded', function () {
  new Splide( '#image-slider', {
		width : '100vw',
		height: '100vh',
  } ).mount();
} );
</script>

<!-- Theming-->



  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-3TBBHYXXPR"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-3TBBHYXXPR');
  </script>


    
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  </head>

  <body class="fixed-top-nav ">

    <!-- Header -->

    <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="http://localhost:4000//">
       <span class="font-weight-bold">Pradipta</span>   Bora
      </a>
      
      <!-- Navbar Toogle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              About
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item ">
            <a class="nav-link" href="/blog/">
              Blog
              
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/cv.pdf">
              CV
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                Projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/teaching/">
                Teaching
                
              </a>
          </li>
          
          
          
          
          
          
          
          
          
        </ul>
      </div>
    </div>
  </nav>

</header>


    <!-- Content -->

    <div class="container mt-5">
      

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Introduction To Reverse Engineering</h1>
    <p class="post-meta">July 17, 2020</p>
  </header>

  <article class="post-content">
    <p>Reverse Engineering is one of the most interesting fields in cybersecurity and ethical hacking. Through this post we will try to simplify this field by going through the ideas involved in a step by step manner. We’ll be focussing on simple ELF Linux executables for now and later on we will also investigate reverse engineering windows exe executables and bytecode for JVM etc. So let’s get started!</p>

<h2 id="what-is-reverse-engineering">What is Reverse Engineering?</h2>

<p>In simple terms Reverse Engineering refers to the process of deconstructing any engineered object to figure out the internal mechanisms. One example would be cracking games where crackers have to reverse engineer the game code on their PC in order to be able to distribute it for free.</p>

<p>Most software that is not open source does not provide it’s source code and instead we have the compiled executable code with us. We have to in a way figure out what the soruce was (or a subset of it) from the executable code. This in general is not easy to do so because machine/assembly code is far complex and also has a lot of compiler optimisations added to it.</p>

<p>In general the executable provided to us may not be binary or assembly instructions it could also be in the form of platform independent byte code that any virtual machine (say the Java virtual machine) executes. We will however look at only Linux executables generated from C/C++ code in this tutorial as that provides a pretty great overview of the field. To do so however we must understand basic assembly.</p>

<h2 id="introduction-to-x86-assembly">Introduction to x86 Assembly</h2>

<p>x86 Assembly is the assembly instruction code used by the non ARM (Intel/AMD) processors and most CTF problems will use this instruction code. The instructions generated may vary from OS to OS and we will consider linux executables (ELF format).
Also before proceeding note that there a variety of different assembly syntaxes, we will be using Intel Assembly syntax in this tutorial although the alternative AT&amp;T syntax is also quite common.</p>

<p>Assembly language has very few constructs compared to higher level languages, instead having to rely on some primitive operations. Most assembly operations happen with respect to registers, which are special memory locations on the CPU which is way faster than directly accessing RAM and a lot of special values are stored here. We will first go through these registers and their naming conventions:</p>

<h3 id="registers">Registers</h3>

<p>A register can be thought of as a special memory location in the CPU. There are 6 general purpose registers and 2 special registers available. We can do all possible assembly operations on these registers like adding values, subtracting etc.</p>

<p>The 8 registers are named as <code class="language-plaintext highlighter-rouge">EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP</code>.</p>

<p>However if you go through any assembly code you will see various variations in the register names. There are different ways in which you can call different registers.
The above naming provides you access to the 32 bits associated with every register. Nowadays in 64 bit systems each register is allocated 64 bits which can be called by using the names <code class="language-plaintext highlighter-rouge">RAX, RBX, RCX, RDX, RSI, RDI, RSP, RBP</code>.</p>

<p>Similarly if you want only 16 bits you will call them as <code class="language-plaintext highlighter-rouge">AX, BX, CX.. </code> and so on. To get eight bits you will use <code class="language-plaintext highlighter-rouge">AL, BL, CL..</code> and so on. The following diagram explains this better:</p>

<p><img src="//images/x86-registers.png" alt="registers" class="img-fluid rounded" /></p>

<p>For more details on registers go through <a href="https://wiki.skullsecurity.org/index.php?title=Registers">this link</a>
The general purpose registers can be used for computation and infact it is only through these registers that you can do operations like addition subtraction. So if you want to say add two numbers stored at two different memory locations you would have to load the values stored there into the registers and then operate and then write these values again into the memory location. We will not be going into specifics of these operations instead we will quickly summarise them below.</p>

<p>One more important thing to note is that <code class="language-plaintext highlighter-rouge">ESP and EBP</code> are used to store the memory location of the stack. <code class="language-plaintext highlighter-rouge">ESP</code> points to the top of the stack and <code class="language-plaintext highlighter-rouge">EBP</code> (generally) refers to the bottom. Declaring variables on the stack would therefore be equivalent to adding and subtracting values from <code class="language-plaintext highlighter-rouge">ESP</code> and <code class="language-plaintext highlighter-rouge">EBP</code>. Note that you generally don’t need to know the exact specifics but having a vague idea works.</p>

<p>There are also a couple of FLAGS that are used by assembly. Think of a flag as a specific boolean variable which is set by assembly instructions. Some flags are the zero flag, the sign flag etc. We will mostly be needing the zero flag in reverse engineering since this flag is used many times to determine control flow.</p>

<h3 id="basic-assembly-operations">Basic Assembly Operations</h3>

<h4 id="mov-operation"><code class="language-plaintext highlighter-rouge">mov</code> operation</h4>
<p>The <code class="language-plaintext highlighter-rouge">mov</code> operation is one of the simplest operations and all it does is moves values (or assigns values). The syntax of <code class="language-plaintext highlighter-rouge">mov</code> is the following:</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">mov destination, source</code></pre></figure>

<p>Suppose I want to set the value <code class="language-plaintext highlighter-rouge">12</code> in <code class="language-plaintext highlighter-rouge">EAX</code> then I would run the operation:</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">mov eax, 12</code></pre></figure>

<p>One more thing to understand is dereferencing. This is similar to C. Suppose the register <code class="language-plaintext highlighter-rouge">ECX</code> holds the value <code class="language-plaintext highlighter-rouge">0x6665f</code> which is a memory location. <code class="language-plaintext highlighter-rouge">ECX</code> is therfore similar to a pointer. If I want to load the value stored at <code class="language-plaintext highlighter-rouge">0x6665f</code> into <code class="language-plaintext highlighter-rouge">EAX</code> I will use the following command:</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">mov eax, [ecx]</code></pre></figure>

<p>The brackets <code class="language-plaintext highlighter-rouge">[]</code> functions similar to <code class="language-plaintext highlighter-rouge">*</code> in C/C++ and it dereferences the memory location and outputs the value at that location.</p>

<h4 id="add-operation"><code class="language-plaintext highlighter-rouge">add</code> operation</h4>

<p>This is pretty simple. Consider the following assembly code:</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">add eax, ebx</code></pre></figure>

<p>This is equivalent to:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">eax</span> <span class="o">=</span> <span class="n">eax</span> <span class="o">+</span> <span class="n">ebx</span></code></pre></figure>

<h4 id="sub-operation"><code class="language-plaintext highlighter-rouge">sub</code> operation</h4>

<p>This is similar as well. Consider the following assembly code:</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">sub eax, ebx</code></pre></figure>

<p>This is equivalent to:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">eax</span> <span class="o">=</span> <span class="n">eax</span> <span class="o">-</span> <span class="n">ebx</span></code></pre></figure>

<h4 id="cmp-operation"><code class="language-plaintext highlighter-rouge">cmp</code> operation</h4>

<p>This is a very useful operation and is used for comparing values. The result of this operation can be combined with <code class="language-plaintext highlighter-rouge">jump</code> operations to dictate control flow. Consider the following code:</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">cmp ecx, 15h
jz 0x7eb </code></pre></figure>

<p>Let’s see what this does. The <code class="language-plaintext highlighter-rouge">cmp</code> command compares the values given to it, in this case it is the value stored in <code class="language-plaintext highlighter-rouge">ecx</code> and the value <code class="language-plaintext highlighter-rouge">21</code> given as hexadecimal. <code class="language-plaintext highlighter-rouge">cmp</code> essentially subtracts these two values and sets some <code class="language-plaintext highlighter-rouge">FLAGS</code> which we talked about before. Here if both the values are equal then the subtraction will be <code class="language-plaintext highlighter-rouge">0</code> and so the <code class="language-plaintext highlighter-rouge">ZERO</code> flag will be set.</p>

<p>The next instruction <code class="language-plaintext highlighter-rouge">jz</code> stands for “jump if zero”. Thus if the zero flag is set the program jumps to the code location charactersised by <code class="language-plaintext highlighter-rouge">0x7eb</code> address (this is easily seen by using a debugger). Thus this is similar to an “if” statement.</p>

<p>Turns out we can use such commands clever to construct <code class="language-plaintext highlighter-rouge">for</code>, <code class="language-plaintext highlighter-rouge">while</code> and other loops. We will go through this in the next article. Instead of using <code class="language-plaintext highlighter-rouge">jz</code> if we used <code class="language-plaintext highlighter-rouge">jle</code> the jump would have happened if <code class="language-plaintext highlighter-rouge">ecx &lt;= 15h</code> was satisfied. Indeed a variety of such conditionals can be used to simulate control flow.</p>

<h4 id="push-and-pop"><code class="language-plaintext highlighter-rouge">push</code> and <code class="language-plaintext highlighter-rouge">pop</code></h4>

<p>These are not really that important for us. The syntax is mostly of the form:</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">push/pop register</code></pre></figure>

<p>This operation is responsible for pushing/poping values onto the stack. We will not be using this much.</p>

<h4 id="test-operation"><code class="language-plaintext highlighter-rouge">test</code> operation</h4>

<p>This is similar to <code class="language-plaintext highlighter-rouge">cmp</code> except it computes the binary <code class="language-plaintext highlighter-rouge">AND</code> instead of subtracting.
Thus if the binary <code class="language-plaintext highlighter-rouge">AND</code> of the two inputs given is <code class="language-plaintext highlighter-rouge">0</code> then the zero flag is set.</p>

<p>The following <code class="language-plaintext highlighter-rouge">C</code> conditional can thus be easily translated into assembly:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">eax</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
	<span class="c1">// do stuff</span>
<span class="p">}</span></code></pre></figure>

<p>The corresponding assembly will be:</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">test eax, eax
jz location_to_do_stuff</code></pre></figure>

<h4 id="lea-operation"><code class="language-plaintext highlighter-rouge">lea</code> operation.</h4>

<p>This is the final operation that we will see here. This is similar to <code class="language-plaintext highlighter-rouge">mov</code> but instead of copying the value it copies the address.</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">lea eax, [ecx]</code></pre></figure>

<p>The above code will copy the value stored in <code class="language-plaintext highlighter-rouge">ecx</code> (that is, the address) into <code class="language-plaintext highlighter-rouge">eax</code>. Observe that <code class="language-plaintext highlighter-rouge">mov</code> would have copied the value stored in the address stored in <code class="language-plaintext highlighter-rouge">ecx</code>. Thus <code class="language-plaintext highlighter-rouge">lea</code> loads the address instead of the value. It stands for load effective address.</p>

<h2 id="introduction-to-static-disassembly-for-reverse-engineering">Introduction to Static Disassembly for Reverse Engineering.</h2>

<p>A lot of theory was seen so far. Let us now see how we could put it all into practice!</p>

<p>We would need a disassembler to get and investigate the assembly code. Let us use a static disassembler for now. A static disassembler does not allow us to run the file but it provides a neat disassembled analysis of the assembly code. IDA is the industry standard for this and download and run the free version of IDA from <a href="https://www.hex-rays.com/products/ida/support/download_freeware.shtml">here</a></p>

<p>Once you have installed IDA Free, you can start working and analysing the code. Let us solve this <a href="https://ctflearn.com/challenge/379">CTFLearn challenge</a> using IDA.</p>

<p>Download the file and load it into IDA. Keep on clicking next, do not change any options (let IDA decide that it is an ELF for instance!). You should arrive at the following screen:
<img src="//images/ida.png" alt="" class="img-fluid rounded" /></p>

<p>If you run the file you observe that you need to enter a pin for this to work. If you enter any random input it will output “PIN Salah!” Clearly we want to find the PIN which gives the other possibility.</p>

<p>The above branches show the other possibility, you want to get “PIN benar!”. Observe that via <code class="language-plaintext highlighter-rouge">test</code> the only way we can get “PIN Salah!” is if <code class="language-plaintext highlighter-rouge">EAX</code> held the value 0.</p>

<p>So somehow when we enter the wrong PIN <code class="language-plaintext highlighter-rouge">EAX</code> is set to 0. Observe that there is an instruction called <code class="language-plaintext highlighter-rouge">call cek</code>. <code class="language-plaintext highlighter-rouge">call</code> in assembly means that we are calling a function. Double click there to see what the code for the <code class="language-plaintext highlighter-rouge">cek</code> function is:</p>

<p><img src="//images/cek.png" alt="" class="img-fluid rounded" /></p>

<p>One important thing to note is that in reverse engineering never try to analyse everything since a lot of it is generated via the compiler and could be hard to make sense of. Instead try to gain an insight into the structure of how the program is operating.</p>

<p>Now we see that well after everything that happens in the upper block in <code class="language-plaintext highlighter-rouge">cek</code> there are two routes. One route sets <code class="language-plaintext highlighter-rouge">eax</code> to <code class="language-plaintext highlighter-rouge">1</code> and else to <code class="language-plaintext highlighter-rouge">0</code>. Clearly we want to see when the value is set to <code class="language-plaintext highlighter-rouge">1</code> as only then the pin is correct.</p>

<p>The branching is decided by <code class="language-plaintext highlighter-rouge">jnz</code>. This means “jump if not zero”. And as we are using <code class="language-plaintext highlighter-rouge">cmp</code> this means that only when the zero flag is set we won’t jump (and hence get <code class="language-plaintext highlighter-rouge">EAX</code> as 1).</p>

<p>When is the zero flag set? This happens only when <code class="language-plaintext highlighter-rouge">[rbp+var_4] == eax</code>. However the above two <code class="language-plaintext highlighter-rouge">movs</code> show that the value now in <code class="language-plaintext highlighter-rouge">[rbp+var_4]</code> is the same as the value in <code class="language-plaintext highlighter-rouge">edi</code> and that in <code class="language-plaintext highlighter-rouge">eax</code> was in something called <code class="language-plaintext highlighter-rouge">cs:valid</code>.</p>

<p>What is this <code class="language-plaintext highlighter-rouge">cs:valid</code>? Turns out it’s just a name given by <code class="language-plaintext highlighter-rouge">IDA</code> to some value stored in the binary. If we double click this we get the following value data:</p>

<p><img src="//images/valid.png" alt="" class="img-fluid rounded" /></p>

<p>Now we haven’t seen where our input is getting stored. Turns out it is getting stored in <code class="language-plaintext highlighter-rouge">EDI</code>. This in general changes but using something called a dynamic disassembler (gdb) we can figure this out (we’ll see this in the next tutorial). Even without knowing this we could guess that well the input is stored in <code class="language-plaintext highlighter-rouge">EDI</code> and as we will see this guess turns out to be right.</p>

<p>So if our input is equal to the value <code class="language-plaintext highlighter-rouge">51615h</code> (which is given in hex) we will get <code class="language-plaintext highlighter-rouge">1</code> in <code class="language-plaintext highlighter-rouge">EAX</code> and hence that has to be the PIN! Converting this to binary we get <code class="language-plaintext highlighter-rouge">333333</code> as this value.</p>

<p>Let us input this and see what wheter this is correct or not.</p>

<p><img src="//images/final.png" alt="" class="img-fluid rounded" /></p>

<p>And indeed we get “PIN benar!” This is the PIN and we found the PIN using some clever disassembly and investigative skills!</p>

<p>This sums up this problem. This was actually one of the simpler reverse engineering problems since we could solve it using only a static disassembler. Later on we will see some more complex problems that have to be solved using other tools like <code class="language-plaintext highlighter-rouge">gdb</code>, <code class="language-plaintext highlighter-rouge">radare2</code> etc.</p>

<p>This is the end of this tutorial. Feel free to try out more problems using IDA and also remember to google a lot. Understanding assembly isn’t easy and one has to frequently google to figure out what each operation is doing. That’s it have fun and keep hacking!</p>


  </article>

  

</div>

    </div>

    <!-- Footer -->

    
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2021 Pradipta  Bora.
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a>

    
    Last updated: November 23, 2021.
    
  </div>
</footer>



  </body>

  <!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>

  <!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>

  
<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>


  


<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>

<!-- Load DarkMode JS -->
<script src="/assets/js/dark_mode.js"></script>


</html>
